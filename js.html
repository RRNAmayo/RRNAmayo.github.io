<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="css/bootstrap.min.css" rel="stylesheet">
		<link href="css/common.css" rel="stylesheet">
		<title>笔记整理</title>
	</head>
	<body>
		<nav id="top_nav" class="navbar navbar-inverse">
		  <div class="container-fluid">
		    <!-- Brand and toggle get grouped for better mobile display -->
		    <div class="navbar-header">
		    	<a class="navbar-brand" href="#">
		        <img alt="CMJ" src="img/CMJ_20.png">
		        <!-- <span>知识结构整理</span> -->
		      </a>
		      <a class="navbar-brand" href="#">
		        <span>笔记整理</span>
		      </a>
		    </div>
		
		    <!-- Collect the nav links, forms, and other content for toggling -->
		    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
		      <ul class="nav navbar-nav">
		        <li><a href="internet.html">计算机网络</a></li>
		        <li><a href="data_structure.html">数据结构</a></li>
		        <li><a href="os.html">操作系统</a></li>
		        <li><a href="db.html">数据库</a></li>
		        <li class="dropdown active">
		          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">web前端 <span class="caret"></span></a>
		          <ul class="dropdown-menu">
		            <li><a href="#">HTML</a></li>
		            <li><a href="#">CSS</a></li>
		            <li class="active"><a href="js.html">JavaScript</a></li>
		            <li role="separator" class="divider"></li>
		            <li><a href="#">highcharts</a></li>
		            <li role="separator" class="divider"></li>
		            <li><a href="#">codeignitor</a></li>
		          </ul>
		        </li>
		      </ul>
		      
		      <ul class="nav navbar-nav navbar-right">
		        <li><a href="index.html" ><span class="glyphicon glyphicon-user"></span>个人简历</a></li>
		        <li><a href="paintings.html"><span class="glyphicon glyphicon-pencil"></span>绘画作品</a></li>
		        <li><a href="contact.html"><span class="glyphicon glyphicon-envelope"></span>与我联系</a></li>
		      </ul>
		    </div><!-- /.navbar-collapse -->
		  </div><!-- /.container-fluid -->
		</nav>
		
		<aside id="aside">
			<div class="list-group">
			  <a href="#closure"    class="list-group-item">js闭包</a>
			  <a href="#ajax"    class="list-group-item">AJAX</a>
			  <a href="#jqueryajax"    class="list-group-item">JQuery AJAX</a>
			  <a href="#inherit"    class="list-group-item">js继承</a>
			</div>
		</aside>
		<article id="article">
			<section name="closure" id="closure">
				<h1>js闭包</h1>
				<div class="pre">
				<h3>闭包的概念</h3>
				<p>闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，
					因此可以把闭包简单理解成“定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 </p>
				<h3>闭包的应用场景</h3>
				<p>1、可以在函数外部对函数内部的局部变量进行操作。保护函数内的变量安全，只有子函数能访问父函数内的变量，而无法通过其他途径访问到。</p>
				<p>2、在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。</p>
				<h3>闭包实例--计数器</h3>
				<a href="http://www.runoob.com/try/try.php?filename=tryjs_function_counter3">运行计数器</a>
				<p>变量 add指定了函数自我调用的返回字值。自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。
					add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。这个叫作 JavaScript闭包。
					它使得函数拥有私有变量变成可能。计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p>
<pre class="code">
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();
function myFunction(){
    document.getElementById("demo").innerHTML = add();
}
</pre>
				<p>“(function(){})()”是函数的一次执行，上面代码也可以写成：</p>
<pre class="code">
function fun() {
var counter = 0;
return function () {return counter += 1;}
};
var add = fun();
function myFunction(){
    document.getElementById("demo").innerHTML = add();
}
</pre>
				</div>
			</section>
			<section name="ajax" id="ajax">
				<h1>AJAX</h1>
				<div class="pre">
					<h3>ALAX实例</h3>
<pre class="code">
var xmlhttp=new XMLHttpRequest();
xmlhttp.onreadystatechange=function()
{
	if (xmlhttp.readyState==4 && xmlhttp.status==200)
	{
 	  document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
  	}
}
xmlhttp.open("POST","test.txt",true);
xmlhttp.send();
</pre>
			<h3>GET 还是 POST？</h3>
			<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：</p>
			<ui>
				<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
				<li>向服务器发送大量数据（POST 没有数据量限制）</li>
				<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
			</ui>
				</div>
			</section>
			<section name="jqueryajax" id="jqueryajax">
				<h1>JQuery AJAX</h1>
				<div class="pre">
					<h3>$.ajax()方法</h3>
<pre class="code">
$("button").click(function(){
	$.ajax({url:"test.txt",
	dataType:"text",
	async:true,
	type:"GET",
	success:function(result){
		$("#div1").html(result);
	}});
});
</pre>
					<ul>dataType:
						<li>"xml" - 一个 XML 文档</li>
						<li>"html" - HTML 作为纯文本</li>
						<li>"text" - 纯文本字符串</li>
						<li>"script" - 以 JavaScript 运行响应，并以纯文本返回</li>
						<li>"json" - 以 JSON 运行响应，并以 JavaScript 对象返回</li>
						<li>"jsonp" - 使用 JSONP 加载一个 JSON 块，将添加一个 "?callback=?" 到 URL 来规定回调</li>
					</ul>
					<h3>$.get()方法</h3>
					<pre class="code">$.get(URL,data,function(data,status,xhr),dataType)</pre>
<pre class="code">
$("button").click(function(){
	$.get("/try/ajax/demo_test.php",function(data,status){
		alert("数据: " + data + "\n状态: " + status);
	});
});
</pre>
					<h3>$.post()方法</h3>
					<pre class="code">$.post(URL,data,function(data,status,xhr),dataType)</pre>
<pre class="code">
$("button").click(function(){
	$.post("/try/ajax/demo_test_post.php",{
		name:"菜鸟教程",
		url:"http://www.runoob.com"
	},
	function(data,status){
		alert("数据: \n" + data + "\n状态: " + status);
	});
});
</pre>				
					<h3>$.getJSON()方法</h3>
					<pre class="code">$.getJSON(url,data,funciton(data,status,xhr))</pre>
<pre class="code">
$("#btn1").click(function(){
  	$.getJSON("test.json",function(json){
	  alert("JSON Data: " + json.employees[1].firstName);
	});
 })
</pre>
<p>getJSON()方法使用 AJAX 的 HTTP GET 请求获取 JSON 数据,相当于：</p>
<pre class="code">
$.ajax({
	url:"test.json",
	dataType:"json",
	success:function(json){
		alert("JSON Data: " + json.employees[1].firstName);
	}
})
</pre>
					<h3>load()方法</h3>
					<pre class="code">$(selector).load(URL,data,callback);</pre>
					<ul>
						<li>必需的 URL 参数规定您希望加载的 URL。</li>
						<li>可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。</li>
						<li>可选的 callback 参数是 load() 方法完成后所执行的函数名称。</li>
					</ul>
					<pre class="code">
$("button").click(function(){
    $("#div1").load("/try/ajax/demo_test.txt",function(responseTxt,statusTxt,xhr){
      if(statusTxt=="success")
        alert("外部内容加载成功!");
      if(statusTxt=="error")
        alert("Error: "+xhr.status+": "+xhr.statusText);
    });
});
</pre>
				</div>
				
			</section>
			<section name="inherit" id="inherit">
				<h1>JS继承</h1>
				<div class="pre">
					JavaScript 中的继承机制并不是明确规定的，而是通过模仿实现的。
					<h3>对象冒充</h3>
					<p>其原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。
						因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。
						ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB。<b>对象冒充可以实现多重继承。</b>
					</p>
<pre class="code">
function ClassA(sColor) {
    this.color = sColor;
    this.sayColor = function () {
        alert(this.color);
    };
}

function ClassB(sColor, sName) {
    this.newMethod = ClassA;
    this.newMethod(sColor);
    delete this.newMethod;

    this.name = sName;
    this.sayName = function () {
        alert(this.name);
    };
}
</pre>
				<h3>call()方法</h3>
				<p>call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。
					二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：
				</p>
    			<pre class="code">var func1 = function(arg1, arg2) {};</pre>
				<p>就可以通过 func1.call(this, arg1, arg2); 或者 func1.apply(this, [arg1, arg2]); 
					来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，
					call需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。
				</p>
				<p>call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p>
<pre class="code">
function sayColor(sPrefix,sSuffix) {
    alert(sPrefix + this.color + sSuffix);
};

var obj = new Object();
obj.color = "blue";

sayColor.call(obj, "The color is ", "a very nice color indeed.");
</pre>
<p>要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可：</p>
<pre class="code">
function ClassB(sColor, sName) {
    //this.newMethod = ClassA;
    //this.newMethod(color);
    //delete this.newMethod;
    ClassA.call(this, sColor);

    this.name = sName;
    this.sayName = function () {
        alert(this.name);
    };
}
</pre>
				<h3>原型链</h3>
				<p></p>
<pre class="code">
function ClassA() {
}

ClassA.prototype.color = "blue";
ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB() {
}

ClassB.prototype = new ClassA();
</pre>
				</div>
			</section>
		</article> 
		<script src="js/jquery-1.11.2.js"></script>
		<script src="js/bootstrap.min.js"></script>
	</body>
</html>